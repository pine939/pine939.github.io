---
title: "[전문가를 위한 C++] 14장. 에러 처리하기"
excerpt: "C++ 교재 '전문가를 위한 C++' 북러닝 요약입니다."

categories:
  - 'cpp'
tags:
  - bookstudy
  - cpp

toc: true
toc_sticky: true
sidebar:
  nav: docs
date: 2022-06-12
last_modified_at: 2022-06-13
---

## Chapter 14. 에러 처리하기

### 14.1 에러와 예외

### 14.2 익셉션 처리 과정

* 익셉션 객체는 항상 const 레퍼런스로 받는 것이 좋다. 익셉션 객체를 값으로 받으면 객체 슬라이싱이 발생한다.

  ```cpp
  } catch (const exception& e) {
  ```
* 여러 가지 익셉션 던지고 받기
  * exception을 상속한 runtime_error로 구현해 보자. 이 타입은 생성자를 호출할 때 예외에 대한 설명을 지정할 수 있다. runtime_error 익셉션 클래스는 \<stdexcept\> 헤더에 정의돼 있다.

    ```cpp
    // 아래와 같이 2가지 상황에서 익셉션을 던졌다고 가정하자.
    throw runtime_error("Unable to open the file")
    throw runtime_error("Error reading the file")

    // main함수 : catch 구문이 runtime_error의 베이스 클래스인 exception 타입을 받도록 구현했다.
    // 따라서 위 2가지 에러를 모두 처리할 수 있다.
    try{
      myInt = readInteger(fileName);
    } catch (const exception& e) {
      cerr << e.what() << endl;
    }
    ```
  * 모든 익셉션 매칭하기
    * catch 문에서 모든 종류의 익셉션에 매칭하려면 다음과 같이 특수한 문법으로 작성한다.
       
       ```cpp
       } catch (...) {
        cerr << "Error reading or opening file" << fileName << endl;
       }
       ```
* noexcept
  * noexcept 키워드가 지정된 함수는 익셉션을 던지지 않는다.
  * 파생 클래스에서 virtual 메서드를 오버라이드할 때 베이스 클래스에 정의된 메서드에 noexcept가 지정되지 않았어도 오버라이드하는 메서드에 noexcept를 지정할 수 있다. 하지만 그 반대로는 할 수 없다.

### 14.3 익셉션과 다형성 

* 익셉션 클래스 직접 정의하기 
  * 익셉션을 직접 정의할 때는 반드시 표준 exception 클래스를 직접 또는 간접적으로 상속하는 것이 좋다.
     
     ```cpp
     class FileError : public exception {
      public:
        FileError(string_view fileName) : mFileName(fileName) {}
        virtual const char* what() const noexcept override {
          return mMessage.cstr();
        }
        string_view getFileName() const noexcept { return mFileName};
      protected:
        void setMessage(string_view message) { mMessage = message;}
      private:
        string mFileName;
        string mMessage;
     }
     ```
  * 익셉션으로 사용할 클래스를 정의할 때는 객체를 복제하거나 이동할 수 있도록 소멸자, 복제 생성자, 대입 연산자 그리고 이동 생성자와 이동 대입 연산자를 함께 정의해야 한다.
  * 익셉션을 레퍼런스로 받으면 쓸데 없는 복제 연산을 방지할 수 있다.
* 중첩된 익셉션
  * 어떤 익셉션을 처리하는 catch문 안에서 새로운 익셉션을 던지고 싶다면 std::throw_with_nested()를 사용하면 된다. 나중에 발생한 익셉션을 처리하는 catch문에서 먼저 발생했던 익셉션에 접근할 때는 dynamic_cast()를 이용하면 된다. 이 때 먼저 발생한 익셉션은 nested_exception으로 표현한다.

### 14.4 익셉션 다시 던지기 

* 익셉션을 다시 던질 때는 반드시 **throw;**로 적어야 한다. e라는 익셉션을 던지기 위해 throw e;와 같이 작성하면 안 된다.

### 14.5 스택 풀기와 청소

### 14.6 익셉션 처리 과정에서 흔히 발생하는 문제

### 14.7 모두 합치기 