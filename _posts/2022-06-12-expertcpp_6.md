---
title: "[전문가를 위한 C++] 14장. 에러 처리하기"
excerpt: "C++ 교재 '전문가를 위한 C++' 북러닝 요약입니다."

categories:
  - 'cpp'
tags:
  - bookstudy
  - cpp

toc: true
toc_sticky: true
sidebar:
  nav: docs
date: 2022-06-12
last_modified_at: 2022-06-12
---

## Chapter 14. 에러 처리하기

### 14.1 에러와 예외

### 14.2 익셉션 처리 과정

* 익셉션 객체는 항상 const 레퍼런스로 받는 것이 좋다. 익셉션 객체를 값으로 받으면 객체 슬라이싱이 발생한다.

  ```cpp
  } catch (const exception& e) {
  ```
* 여러 가지 익셉션 던지고 받기
  * exception을 상속한 runtime_error로 구현해 보자. 이 타입은 생성자를 호출할 때 예외에 대한 설명을 지정할 수 있다. runtime_error 익셉션 클래스는 \<stdexcept\> 헤더에 정의돼 있다.

    ```cpp
    // 아래와 같이 2가지 상황에서 익셉션을 던졌다고 가정하자.
    throw runtime_error("Unable to open the file")
    throw runtime_error("Error reading the file")

    // main함수 : catch 구문이 runtime_error의 베이스 클래스인 exception 타입을 받도록 구현했다.
    // 따라서 위 2가지 에러를 모두 처리할 수 있다.
    try{
      myInt = readInteger(fileName);
    } catch (const exception& e) {
      cerr << e.what() << endl;
    }
    ```
  * 모든 익셉션 매칭하기
    * catch 문에서 모든 종류의 익셉션에 매칭하려면 다음과 같이 특수한 문법으로 작성한다.
       
       ```cpp
       } catch (...) {
        cerr << "Error reading or opening file" << fileName << endl;
       }
       ```
* noexcept
  * noexcept 키워드가 지정된 함수는 익셉션을 던지지 않는다.
  * 파생 클래스에서 virtual 메서드를 오버라이드할 때 베이스 클래스에 정의된 메서드에 noexcept가 지정되지 않았어도 오버라이드하는 메서드에 noexcept를 지정할 수 있다. 하지만 그 반대로는 할 수 없다.

### 14.3 익셉션과 다형성 

### 14.4 익셉션 다시 던지기 

### 14.5 스택 풀기와 청소

### 14.6 익셉션 처리 과정에서 흔히 발생하는 문제

### 14.7 모두 합치기 